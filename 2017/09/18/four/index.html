<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>ES6核心内容 | welcome</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="John Doe">
  
  
    <meta name="description" content="https://segmentfault.com/a/1190000004365693
ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。
也就是说，ES6就是ES2015。
虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算">
  
  <meta name="description" content="https://segmentfault.com/a/1190000004365693 ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 也就是说，ES6就是ES2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6核心内容">
<meta property="og:url" content="http://yoursite.com/2017/09/18/four/index.html">
<meta property="og:site_name" content="welcome">
<meta property="og:description" content="https://segmentfault.com/a/1190000004365693 ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 也就是说，ES6就是ES2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算">
<meta property="og:updated_time" content="2017-09-18T13:10:37.914Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6核心内容">
<meta name="twitter:description" content="https://segmentfault.com/a/1190000004365693 ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 也就是说，ES6就是ES2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">welcome</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/reading">Reading</a></li>
      
        <li><a href="/about">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/09/18/four/">
  <time datetime="2017-09-18T13:08:25.000Z">
    2017-09-18
  </time>
</a>
    
    
  
    <h1 class="title">ES6核心内容</h1>
  

  </header>
  
  <div class="entry">
    
      <p><a href="https://segmentfault.com/a/1190000004365693" target="_blank" rel="external">https://segmentfault.com/a/1190000004365693</a></p>
<p>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。</p>
<p>也就是说，ES6就是ES2015。</p>
<p>虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了…</p>
<p>在我们正式讲解ES6语法之前，我们得先了解下Babel。<br>Babel</p>
<p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看：<br>最常用的ES6特性</p>
<p>let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments<br>这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。<br>let, const</p>
<p>这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。<br>首先来看下面这个例子：</p>
<p>var name = ‘zach’</p>
<p>while (true) {<br>    var name = ‘obama’<br>    console.log(name)  //obama<br>    break<br>}</p>
<p>console.log(name)  //obama</p>
<p>使用var 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。</p>
<p>let name = ‘zach’</p>
<p>while (true) {<br>    let name = ‘obama’<br>    console.log(name)  //obama<br>    break<br>}</p>
<p>console.log(name)  //zach</p>
<p>另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：</p>
<p>var a = [];<br>for (var i = 0; i &lt; 10; i++) {<br>  a[i] = function () {<br>    console.log(i);<br>  };<br>}<br>a<a href="">6</a>; // 10</p>
<p>上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。</p>
<p>var a = [];<br>for (let i = 0; i &lt; 10; i++) {<br>  a[i] = function () {<br>    console.log(i);<br>  };<br>}<br>a<a href="">6</a>; // 6</p>
<p>再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。</p>
<p>var clickBoxs = document.querySelectorAll(‘.clickBox’)<br>for (var i = 0; i &lt; clickBoxs.length; i++){<br>    clickBoxs[i].onclick = function(){<br>        console.log(i)<br>    }<br>}</p>
<p>我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。</p>
<p>function iteratorFactory(i){<br>    var onclick = function(e){<br>        console.log(i)<br>    }<br>    return onclick;<br>}<br>var clickBoxs = document.querySelectorAll(‘.clickBox’)<br>for (var i = 0; i &lt; clickBoxs.length; i++){<br>    clickBoxs[i].onclick = iteratorFactory(i)<br>}</p>
<p>const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。</p>
<p>const PI = Math.PI</p>
<p>PI = 23 //Module build failed: SyntaxError: /es6/app.js: “PI” is read-only</p>
<p>当我们尝试去改变用const声明的常量时，浏览器就会报错。<br>const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：</p>
<p>const monent = require(‘moment’)</p>
<p>class, extends, super</p>
<p>这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？</p>
<p>有了ES6我们不再烦恼！</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<p>class Animal {<br>    constructor(){<br>        this.type = ‘animal’<br>    }<br>    says(say){<br>        console.log(this.type + ‘ says ‘ + say)<br>    }<br>}</p>
<p>let animal = new Animal()<br>animal.says(‘hello’) //animal says hello</p>
<p>class Cat extends Animal {<br>    constructor(){<br>        super()<br>        this.type = ‘cat’<br>    }<br>}</p>
<p>let cat = new Cat()<br>cat.says(‘hello’) //cat says hello</p>
<p>上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。</p>
<p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。</p>
<p>super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承React.Component的类。详见react文档<br>arrow function</p>
<p>这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多:</p>
<p>function(i){ return i + 1; } //ES5<br>(i) =&gt; i + 1 //ES6</p>
<p>简直是简单的不像话对吧…<br>如果方程比较复杂，则需要用{}把代码包起来：</p>
<p>function(x, y) {<br>    x++;<br>    y–;<br>    return x + y;<br>}<br>(x, y) =&gt; {x++; y–; return x+y}</p>
<p>除了看上去更简洁以外，arrow function还有一项超级无敌的功能！<br>长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：</p>
<p>class Animal {<br>    constructor(){<br>        this.type = ‘animal’<br>    }<br>    says(say){<br>        setTimeout(function(){<br>            console.log(this.type + ‘ says ‘ + say)<br>        }, 1000)<br>    }<br>}</p>
<p> var animal = new Animal()<br> animal.says(‘hi’)  //undefined says hi</p>
<p>运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：</p>
<pre><code>第一种是将this传给self,再用self来指代this

   says(say){
       var self = this;
       setTimeout(function(){
           console.log(self.type + &apos; says &apos; + say)
       }, 1000)

2.第二种方法是用bind(this),即

   says(say){
       setTimeout(function(){
           console.log(this.type + &apos; says &apos; + say)
       }.bind(this), 1000)

但现在我们有了箭头函数，就不需要这么麻烦了：
</code></pre><p>class Animal {<br>    constructor(){<br>        this.type = ‘animal’<br>    }<br>    says(say){<br>        setTimeout( () =&gt; {<br>            console.log(this.type + ‘ says ‘ + say)<br>        }, 1000)<br>    }<br>}<br> var animal = new Animal()<br> animal.says(‘hi’)  //animal says hi</p>
<p>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。<br>template string</p>
<p>这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。</p>
<p>大家可以先看下面一段代码：</p>
<p>$(“#result”).append(<br>  “There are <b>“ + basket.count + “</b> “ +<br>  “items in your basket, “ +<br>  “<em>“ + basket.onSale +<br>  “</em> are on sale!”<br>);</p>
<p>我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写：</p>
<p>$(“#result”).append(<code>There are &lt;b&gt;${basket.count}&lt;/b&gt; items
   in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
  are on sale!</code>);</p>
<p>用反引号（\）来标识起始，用${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！</p>
<p>React Router从第1.0.3版开始也使用ES6语法了，比如这个例子：</p>
<link to="{`/taco/${taco.name}`}">{taco.name}

<p>React Router<br>destructuring</p>
<p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>看下面的例子：</p>
<p>let cat = ‘ken’<br>let dog = ‘lili’<br>let zoo = {cat: cat, dog: dog}<br>console.log(zoo)  //Object {cat: “ken”, dog: “lili”}</p>
<p>用ES6完全可以像下面这么写：</p>
<p>let cat = ‘ken’<br>let dog = ‘lili’<br>let zoo = {cat, dog}<br>console.log(zoo)  //Object {cat: “ken”, dog: “lili”}</p>
<p>反过来可以这么写：</p>
<p>let dog = {type: ‘animal’, many: 2}<br>let { type, many} = dog<br>console.log(type, many)   //animal 2</p>
<p>default, rest</p>
<p>default很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || ‘cat’ 来指定默认值。</p>
<p>function animal(type){<br>    type = type || ‘cat’<br>    console.log(type)<br>}<br>animal()</p>
<p>如果用ES6我们而已直接这么写：</p>
<p>function animal(type = ‘cat’){<br>    console.log(type)<br>}<br>animal()</p>
<p>最后一个rest语法也很简单，直接看例子：</p>
<p>function animals(…types){<br>    console.log(types)<br>}<br>animals(‘cat’, ‘dog’, ‘fish’) //[“cat”, “dog”, “fish”]</p>
<p>而如果不用ES6的话，我们则得使用ES5的arguments。<br>总结</p>
<p>以上就是ES6最常用的一些语法，可以说这20%的语法，在ES6的日常使用中占了80%…</p>

    
  </div>
  <footer>
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>
  <div class="ds-thread" data-title="ES6核心内容">
  </div>
</section>
</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">John Doe</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'buru' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>